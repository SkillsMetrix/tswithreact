
interface FullTimeEmp{
    type:'full-time'
    name: string
    salary:number
    benifits:string[]
}

interface PartTimeEmp{
    type:'part-time'
    name: string
    hourlyRAte:number
    hoursPerWeek:number
}

type Employee =FullTimeEmp | PartTimeEmp

function isFullTimeEmp(emp:Employee):emp is FullTimeEmp{
return emp.type ==='full-time'
}

function isPartTimeEmp(emp:Employee):emp is PartTimeEmp{
return emp.type ==='part-time'
}

//using it
function printData(emp:Employee){
    console.log(`Name ${emp.name}`);
    if(isFullTimeEmp(emp)){
        console.log(`Salary ${emp.salary}`);
        
    }else if(isPartTimeEmp(emp)){
        console.log(`Salary ${emp.hourlyRAte}`);
    }
    
}
const emp1:Employee={
    type: 'full-time',
    name: 'jane',
    salary:2323,
    benifits:['']
}
const emp2:Employee={
    type: 'part-time',
    name: 'john',
    
     hourlyRAte:2334
}
printData(emp1)
printData(emp2)

-----

interface Employee{
    id:number
    name:string
}

 namespace Employee{
    export function create(id:number,name:string):Employee{
        return {id,name}
    }
 }

 export function isIntern(employee:Employee):boolean{
    return employee.name.toLowerCase().includes("intern")
 }

 const emp1= Employee.create(101,'Adam')
 const emp2= Employee.create(2,"Bob")

 console.log(emp1);
 console.log(emp2);
 
 

-----
interface BaseEmployee {
    id: number
    name: string
}
interface Engineer extends BaseEmployee{
    skills: string[]
}
interface HrEmployee extends BaseEmployee {
    policies: string[]
}
// generic fun with extends contraint

const printEmployeeDetails = <T extends BaseEmployee>(employee: T):void =>{
console.log(`ID : ${employee.id}, Name : ${employee.name}`);

}
//usage
const engineer:Engineer={
    id:101,
    name:'Bose',
    skills:["TS","react"]
}
const hr:HrEmployee={
    id:102,
    name:'mariya',
    policies:["Dress Policy","Work Policy"]
}
printEmployeeDetails(engineer)
printEmployeeDetails(hr)
 
//------default types

class EmployeeManager<T extends BaseEmployee=BaseEmployee>{
    private employees: T[]=[]
    addEmployee(emp:T):void {
        this.employees.push(emp)
    }
    list():void{
        this.employees.forEach(e=> console.log(`ID: ${e.id}, Name: ${e.name}`))
    }

}
// usage of default
const baseManager= new EmployeeManager()
baseManager.addEmployee({id:103,name:"Dummy user"})
baseManager.list()
// usage with specific type

const engManager= new EmployeeManager<Engineer>()
engManager.addEmployee({id:104,name:"Dummy user",skills:[""]})




-------------------



type Employee= {
    id: number
    name: string
    department:string
    salary: number
    isActive:boolean
}
//partial
function updateEmployee(id:number,updates:Partial<Employee>){
    console.log(`updating employee ${id} with`, updates);
    
}
updateEmployee(101, {name:"Alice",isActive:false})
// Pick
type EmployeeSummary=Pick<Employee , "id" | "name">

const summary: EmployeeSummary={
    id:101,
    name:'tom'
}
//return type

function createEmployee():Employee{
    return {
        id:101,
        name: 'julia',
        department: 'Eng',
        salary :2323,
        isActive: true
    }
}
type CreatedEmployee= ReturnType<typeof createEmployee>
// keep types in sync between fun output and var or other api conuming the result
const newEmp:CreatedEmployee=createEmployee()

//Awaited ( unwraps the resolved type of Promise)

async function fetchEmployee():Promise<Employee> {
    // simulating API calls
   return {
        id:101,
        name: 'julia',
        department: 'Eng',
        salary :2323,
        isActive: true
    }
}

type EmployeeData= Awaited<ReturnType<typeof fetchEmployee>>
const emp: EmployeeData=await fetchEmployee() // same as type Employee
